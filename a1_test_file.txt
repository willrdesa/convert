# CS 3503 Assignment 1 Test Cases
# Format: function_name input1 input2 expected_output
# Lines starting with # are comments
# Empty lines are ignored
#
# NOTE: You are free to break these sections apart into separate files
# or reorganize as needed for your testing approach. The TXT format was
# chosen to give you experience with parsing various data formats you'll
# encounter in systems programming.

# =============================================================================
# DIVISION METHOD TESTS (div_convert)
# =============================================================================

# Basic conversion tests - mirrors original hand calculations
div_convert 104 5 404
div_convert 156 8 234
div_convert 255 16 FF
div_convert 255 10 255
div_convert 255 2 11111111
div_convert 42 2 101010

# Edge cases - zero and small numbers
div_convert 0 2 0
div_convert 0 8 0
div_convert 0 10 0
div_convert 0 16 0
div_convert 1 2 1
div_convert 1 8 1
div_convert 1 16 1

# Powers of base - good algorithm tests
div_convert 8 2 1000
div_convert 16 2 10000
div_convert 64 8 100
div_convert 256 16 100

# Large numbers - test algorithm robustness
div_convert 4294967295 2 11111111111111111111111111111111
div_convert 4294967295 8 37777777777
div_convert 4294967295 10 4294967295
div_convert 4294967295 16 FFFFFFFF

# Mixed base tests
div_convert 42 5 132
div_convert 42 8 52
div_convert 42 10 42
div_convert 42 16 2A

# =============================================================================
# SUBTRACTION METHOD TESTS (sub_convert)
# =============================================================================

# Basic conversion tests - should match division method results
sub_convert 104 5 404
sub_convert 156 8 234
sub_convert 255 16 FF
sub_convert 255 10 255
sub_convert 255 2 11111111
sub_convert 42 2 101010

# Edge cases - zero and small numbers
sub_convert 0 2 0
sub_convert 0 8 0
sub_convert 0 10 0
sub_convert 0 16 0
sub_convert 1 2 1
sub_convert 1 8 1
sub_convert 1 16 1

# Powers of base
sub_convert 8 2 1000
sub_convert 16 2 10000
sub_convert 64 8 100
sub_convert 256 16 100

# Large numbers - test algorithm robustness
sub_convert 4294967295 2 11111111111111111111111111111111
sub_convert 4294967295 8 37777777777
sub_convert 4294967295 10 4294967295
sub_convert 4294967295 16 FFFFFFFF

# Mixed base tests
sub_convert 42 5 132
sub_convert 42 8 52
sub_convert 42 10 42
sub_convert 42 16 2A

# =============================================================================
# ALGORITHM COMPARISON TESTS
# =============================================================================

# These tests verify both algorithms produce identical results
# Students can use these to validate their implementations

# Small comparison tests
div_convert 7 2 111
sub_convert 7 2 111

div_convert 15 8 17
sub_convert 15 8 17

div_convert 31 16 1F
sub_convert 31 16 1F

# Medium comparison tests  
div_convert 1000 2 1111101000
sub_convert 1000 2 1111101000

div_convert 1000 8 1750
sub_convert 1000 8 1750

div_convert 1000 16 3E8
sub_convert 1000 16 3E8

# =============================================================================
# BIT OPERATIONS TESTS (print_tables)
# =============================================================================

# Note: print_tables tests are marked as FORMATTED_OUTPUT
# Students need to implement exact format matching for these tests
# Expected format for each operation (3 lines total):
# Original: Binary=<binary> Octal=<octal> Decimal=<decimal> Hex=<hex>
# Left Shift by 3: Binary=<binary> Octal=<octal> Decimal=<decimal> Hex=<hex>
# AND with 0xFF: Binary=<binary> Octal=<octal> Decimal=<decimal> Hex=<hex>

# Basic bit operations test
print_tables 5
Binary=101 Octal=5 Decimal=5 Hex=5
Left Shift by 3: Binary=101000 Octal=50 Decimal=40 Hex=28
AND with 0xFF: Binary=101 Octal=5 Decimal=5 Hex=5


# Zero test - important edge case
print_tables 0
Binary=0 Octal=0 Decimal=0 Hex=0
Left Shift by 3: Binary=0 Octal=0 Decimal=0 Hex=0
AND with 0xFF: Binary=0 Octal=0 Decimal=0 Hex=0

# Zero test - important edge case
print_tables 0
Binary=0 Octal=0 Decimal=0 Hex=0
Left Shift by 3: Binary=0 Octal=0 Decimal=0 Hex=0
AND with 0xFF: Binary=0 Octal=0 Decimal=0 Hex=0

# Small numbers
print_tables 1
Binary=1 Octal=1 Decimal=1 Hex=1
Left Shift by 3: Binary=1000 Octal=10 Decimal=8 Hex=8
AND with 0xFF: Binary=1 Octal=1 Decimal=1 Hex=1

print_tables 7
Binary=111 Octal=7 Decimal=7 Hex=7
Left Shift by 3: Binary=111000 Octal=70 Decimal=56 Hex=38
AND with 0xFF: Binary=111 Octal=7 Decimal=7 Hex=7

print_tables 15
Binary=1111 Octal=17 Decimal=15 Hex=F
Left Shift by 3: Binary=1111000 Octal=170 Decimal=120 Hex=78
AND with 0xFF: Binary=1111 Octal=17 Decimal=15 Hex=F

# Powers of 2 - good for bit shifting
print_tables 8
Binary=1000 Octal=10 Decimal=8 Hex=8
Left Shift by 3: Binary=1000000 Octal=100 Decimal=64 Hex=40
AND with 0xFF: Binary=1000 Octal=10 Decimal=8 Hex=8

print_tables 16
Binary=10000 Octal=20 Decimal=16 Hex=10
Left Shift by 3: Binary=10000000 Octal=200 Decimal=128 Hex=80
AND with 0xFF: Binary=10000 Octal=20 Decimal=16 Hex=10

print_tables 32
Binary=100000 Octal=40 Decimal=32 Hex=20
Left Shift by 3: Binary=100000000 Octal=400 Decimal=256 Hex=100
AND with 0xFF: Binary=100000 Octal=40 Decimal=32 Hex=20

# Test bit masking with 0xFF
print_tables 255
Binary=11111111 Octal=377 Decimal=255 Hex=FF
Left Shift by 3: Binary=11111111000 Octal=3770 Decimal=2040 Hex=7F8
AND with 0xFF: Binary=11111111 Octal=377 Decimal=255 Hex=FF

print_tables 256
Binary=100000000 Octal=400 Decimal=256 Hex=100
Left Shift by 3: Binary=100000000000 Octal=4000 Decimal=2048 Hex=800
AND with 0xFF: Binary=0 Octal=0 Decimal=0 Hex=0

print_tables 511
Binary=111111111 Octal=777 Decimal=511 Hex=1FF
Left Shift by 3: Binary=111111111000 Octal=7770 Decimal=4088 Hex=FF8
AND with 0xFF: Binary=11111111 Octal=377 Decimal=255 Hex=FF

# Larger numbers
print_tables 1000
Binary=1111101000 Octal=1750 Decimal=1000 Hex=3E8
Left Shift by 3: Binary=1111101000000 Octal=17500 Decimal=8000 Hex=1F40
AND with 0xFF: Binary=11101000 Octal=350 Decimal=232 Hex=E8

print_tables 65535
Binary=1111111111111111 Octal=177777 Decimal=65535 Hex=FFFF
Left Shift by 3: Binary=1111111111111111000 Octal=1777770 Decimal=524280 Hex=7FFF8
AND with 0xFF: Binary=11111111 Octal=377 Decimal=255 Hex=FF

# Maximum value test
print_tables 4294967295
Binary=11111111111111111111111111111111 Octal=37777777777 Decimal=4294967295 Hex=FFFFFFFF
Left Shift by 3: Binary=11111111111111111111111111111000 Octal=37777777770 Decimal=4294967288 Hex=FFFFFFF8
AND with 0xFF: Binary=11111111 Octal=377 Decimal=255 Hex=FF

# =============================================================================
# STRESS TESTS
# =============================================================================

# Test algorithm efficiency with challenging inputs
div_convert 2147483647 2 1111111111111111111111111111111
sub_convert 2147483647 2 1111111111111111111111111111111

div_convert 1073741824 8 10000000000
sub_convert 1073741824 8 10000000000

div_convert 268435456 16 10000000
sub_convert 268435456 16 10000000

# =============================================================================
# BOUNDARY TESTS
# =============================================================================

# Test edge cases near system limits
div_convert 4294967294 10 4294967294
sub_convert 4294967294 10 4294967294

div_convert 4294967294 16 FFFFFFFE
sub_convert 4294967294 16 FFFFFFFE

# Test single digit results in various bases
div_convert 4 5 4
sub_convert 4 5 4

div_convert 7 8 7
sub_convert 7 8 7

div_convert 15 16 F
sub_convert 15 16 F

# =============================================================================
# SPECIAL CASES
# =============================================================================

# Test cases that often reveal implementation bugs

# Base 5 special cases (since it's uncommon)
div_convert 25 5 100
sub_convert 25 5 100

div_convert 124 5 444
sub_convert 124 5 444

# Hex letter cases (should be uppercase)
div_convert 171 16 AB
sub_convert 171 16 AB

# FIXED: Corrected hex conversion (was CAFEBABE, should be CAFFFF00)
div_convert 3405774592 16 CAFFFF00
sub_convert 3405774592 16 CAFFFF00

# End of test file